#! /usr/bin/env python3

"""
Rofi interface for devices

Technically it manages two types of devices with two tools:
- removable media with udiskie
- cifs/nfs with udevil

For the latter this script assumes a table of mounts and options
specified by the GENERAL_MNTS_PATH variable defined below. In addition
to udiskie and udevil, it also assumes that notify-send is installed
so it can spam the user with useful information as well as libsecret
if credentials are stored in the keyring.

TODO
- implement sshfs
- add bulk commands (dis/mount all)
- add argument parsing to make the interface similar to other rofi cmds
  (this is mostly for xmonad so I can easily control which monitor
   gets the rofi box)
"""


import os
import os.path
import re
from subprocess import Popen, PIPE, STDOUT


def remove_none(xs):
    """Accept list XS and return new list with all None's removed."""
    return list(filter(lambda x: x is not None, xs))


def fmt_rofi_entry(is_mounted, path, label):
    """Format an entry for a device as it will appear in the rofi prompt.

    IS_MOUNTED is a boolean flag representing if the device is mounted.
    PATH is the device path for the device. LABEL is the filesystem
    label if the device is a removable drive or some indentifying
    string if not.
    """
    mount_str = "*" if is_mounted else ""
    return "{:2}{} - {}".format(mount_str, label, path)


def notify(res, is_mounted, label):
    """Spawn a notification for device events.

    RES is the object return from Popen (which in this case is assumed
    to be running a mounting event. IS_MOUNTED is a boolean which is
    true of the device in question has been mounted. LABEL is like
    the same argument in "fmt_rofi_entry"
    """
    if res:
        res.communicate()
        status = res.returncode

        if is_mounted:
            subcmd = "unmount"
        else:
            subcmd = "mount"
        if status == 0:
            msg = "Successfully {}ed ".format(subcmd)
        else:
            msg = "Failed to {} ".format(subcmd)

        Popen(["notify-send", msg + label])


class Action(object):
    """A superclass for actions to populate the rofi menu.

    Accepts single attribute ENTRY which is the literal string that
    will appear in the rofi prompt. Equality between two of this type
    will be assessed using the entry attribute.

    The method "run" is a stub to be overridden and will hold the
    command to be performed if the action is selected in the rofi
    prompt.
    """

    def __init__(self, entry):
        self.entry = entry

    def run(self):
        pass

    def __eq__(self, other):
        return self.entry == other


class UdiskieDevice(Action):
    """A class for removable devices queried by udiskie.

    Attributes:
    - is_mounted: boolean (True if the device is mounted)
    - path: the device path
    - label: the filesystem label (if applicable)

    Methods:
    - run: if device is mounted, will unmount the device and vice
      versa; will also notify the user of success or failure for
      mount or dismount operations
    """

    def __init__(self, is_mounted, path, label):
        entry = fmt_rofi_entry(is_mounted, path, label)
        Action.__init__(self, entry)
        self.is_mounted = is_mounted
        self.path = path
        # TODO what if the filesystem has no label?
        self.label = label

    def run(self):
        if self.is_mounted:
            subcmd = "unmount"
        else:
            subcmd = "mount"
        res = Popen(
            ["udisksctl", subcmd, "-b", self.path], stdout=PIPE, stderr=PIPE, text=True,
        )
        notify(res, self.is_mounted, self.label)


class GenericDevice(Action):
    """A class for generic devices to be mounted by udevil and sshfs

    Attributes:
    - label: a string identifier for the device
    - mtype: the type of device to be mounted (eg cifs, sshfs, etc)
    - path: the device path
    - mountpoint: the path where the device is to be mounted; if None
      the default path will be used (eg /mnt/media for udevil)
    - options: the mount options to be used
    - creds: the credentials to be used; for now the only format is a
      string like "secret:key1=val1,key2=val2" where the keys and
      values are attribute/value pairs to be queried with the command
      "secret-tool lookup" (eg the libsecret interface) which should
      return a valid password to be added to the mount options

    Methods:
    - run: if device is mounted, will unmount the device and vice
      versa; will also notify the user of success or failure for
      mount or dismount operations
    """

    def __init__(self, label, mtype, path, mountpoint, options, creds):
        with open("/proc/mounts", "r") as f:
            self.is_mounted = path in f.read()
        entry = fmt_rofi_entry(self.is_mounted, path, label)
        super().__init__(entry)
        self.mtype = mtype
        self.path = path
        self.label = label
        self.options = options
        self.mountpoint = mountpoint
        self.creds = creds

    # TODO add sshfs crap
    def run(self):
        if self.mtype == "sshfs":
            pass  # ssh is special...
        else:
            if self.is_mounted:
                res = self._unmount_udevil()
            else:
                res = self._mount_udevil()
        notify(res, self.is_mounted, self.label)

    def _mount_udevil(self):
        """Mount a device with udevil"""
        opts = self._add_credentials()
        return Popen(
            ["udevil", "mount", "-o", opts, "-t", self.mtype, self.path],
            stdout=PIPE,
            stderr=PIPE,
            text=True,
        )

    def _unmount_udevil(self):
        """Unmount a device with udevil"""
        mountpoint = self._get_mountpoint()
        if mountpoint:
            return Popen(
                ["udevil", "unmount", mountpoint], stdout=PIPE, stderr=PIPE, text=True,
            )

    def _get_mountpoint(self):
        """Return the current mountpoint for self given a device path"""
        with open("/proc/mounts", "r") as f:
            for l in f:
                if self.path in l:
                    return l.split(" ")[1]

    def _add_credentials(self):
        """Return mount options string with password added"""
        if self.creds:
            if self.creds.startswith("secret:"):
                query = self.creds.replace("secret:", "")
                # TODO this might need to change depending on the
                # protocol
                passwd = self._get_secret(query)
                return "{},password={}".format(self.options, passwd)
        return self.options

    def _get_secret(self, query):
        """Return password using secret-tool given QUERY
        QUERY is a string of keyval pairs like "k1=v1,k2=v2"
        """
        cmd = ["secret-tool", "lookup"] + re.split("[=,]", query)
        return Popen(cmd, stdout=PIPE, stderr=STDOUT, text=True).communicate()[0]


#
# Retrieve available removable drives using udiskie
#

UDISKIE_CMD = [
    "udiskie-info",
    "-a",
    "-o",
    "'{is_mounted} {is_filesystem} {device_file} {id_label}'",
]

udiskie_out = (
    Popen(UDISKIE_CMD, stdout=PIPE, stderr=STDOUT, text=True)
    .communicate()[0]
    .strip()
    .split("\n")
)


def udiskie_init(line):
    """Return UdiskieDevice object given a line of udiskie output.
    LINE is a newline-stripped line from "udiskie -a ..." and is
    assumed to be formatted like "IS_MOUNTED IS_FILESYSTEM PATH LABLE".
    Anything that is not a filesystem device will be returned as None."""
    is_mounted, is_fs, path, label = line[1:-1].split(" ")
    if is_fs == "True":
        is_mounted = is_mounted == "True"
        return UdiskieDevice(is_mounted, path, label)


udiskie_actions = (
    remove_none([udiskie_init(line) for line in udiskie_out])
    if len("".join(udiskie_out)) > 0
    else []
)

#
# Retrieve available general devices given a configuration file
#

GENERAL_MNTS_PATH = os.path.join(os.getenv("XDG_CONFIG_HOME"), "rofi", "devices.tsv")

with open(GENERAL_MNTS_PATH, "r") as f:
    # TODO this assumes the tsv file has headers as the first row
    # this may or may not be true
    # assume this will output a [] if the file is empty
    general_out = f.read().rstrip("\n").split("\n")[1:]

general_actions = remove_none(
    [GenericDevice(*line.split("\t")) for line in general_out]
)

#
# Combine all actions and call the rofi interface
#

actions = udiskie_actions + general_actions


def format_actions(action_list):
    return "\n".join(list(map(lambda x: x.entry, action_list)))


def format_options(action_lists):
    fmtd = [format_actions(a) for a in action_lists if len(a) > 0]
    return "\n\n".join(fmtd)


rofi_opts = format_options([udiskie_actions, general_actions])

rofi_cmd = [
    "rofi",
    "-m",
    "-4",
    "-dmenu",
    "-theme-str",
    "#element.selected.normal { background-color: #999933; }",
    "-p",
    "Devices",
]

rofi_out = (
    Popen(rofi_cmd, stdout=PIPE, stderr=STDOUT, text=True, stdin=PIPE)
    .communicate(input=rofi_opts)[0]
    .rstrip()
)

#
# Given entry string from rofi, find corresponding action and execute
#

if rofi_out != "":
    for a in actions:
        if a == rofi_out:
            a.run()
            # TODO throw error if this is never encountered (it means
            # I formated the entries incorrectly)
            break
