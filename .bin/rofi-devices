#! /usr/bin/env python3

"""
Rofi interface for devices

Technically it manages two types of devices with two tools:
- removable media with udiskie
- cifs/nfs with udevil

For the latter this script assumes a table of mounts and options
specified by the GENERAL_MNTS_PATH variable defined below. In addition
to udiskie and udevil, it also assumes that notify-send is installed
so it can spam the user with useful information as well as libsecret
if credentials are stored in the keyring.

TODO
- implement sshfs
- add bulk commands (dis/mount all)
- add argument parsing to make the interface similar to other rofi cmds
  (this is mostly for xmonad so I can easily control which monitor
   gets the rofi box)
"""


import os
import os.path
import re
from subprocess import Popen, PIPE, STDOUT


def remove_none(xs):
    """Accept list XS and return new list with all None's removed."""
    return list(filter(lambda x: x is not None, xs))


def fmt_rofi_entry(is_mounted, path, label):
    """Format an entry for a device as it will appear in the rofi prompt.

    IS_MOUNTED is a boolean flag representing if the device is mounted.
    PATH is the device path for the device. LABEL is the filesystem
    label if the device is a removable drive or some indentifying
    string if not.
    """
    mount_str = "*" if is_mounted else ""
    return "{:2}{} - {}".format(mount_str, label, path)


def notify(res, is_mounted, label):
    """Spawn a notification for device events.

    RES is the object return from Popen (which in this case is assumed
    to be running a mounting event. IS_MOUNTED is a boolean which is
    true of the device in question has been mounted. LABEL is like
    the same argument in "fmt_rofi_entry"
    """
    if res:
        res.communicate()
        status = res.returncode

        if is_mounted:
            subcmd = "unmount"
        else:
            subcmd = "mount"
        if status == 0:
            msg = "Successfully {}ed ".format(subcmd)
        else:
            msg = "Failed to {} ".format(subcmd)

        Popen(["notify-send", msg + label])


class UdiskieDevice(Action):
    def __init__(self, is_mounted, path, label):
        entry = fmt_rofi_label(is_mounted, path, label)
        Action.__init__(self, entry)
        self.is_mounted = is_mounted
        self.path = path
        self.label = label

    def run(self):
        if self.is_mounted:
            subcmd = "unmount"
        else:
            subcmd = "mount"
        res = Popen(
            ["udisksctl", subcmd, "-b", self.path], stdout=PIPE, stderr=PIPE, text=True,
        )
        notify(res, self.is_mounted, self.label)


class GenericDevice(Action):
    def __init__(self, label, mtype, path, mountpoint, options, creds):
        with open("/proc/mounts", "r") as f:
            self.is_mounted = path in f.read()
        entry = fmt_rofi_label(self.is_mounted, path, label)
        super().__init__(entry)
        self.mtype = mtype
        self.path = path
        self.label = label
        self.options = options
        self.mountpoint = mountpoint
        self.creds = creds

    # TODO add sshfs crap
    def run(self):
        if self.mtype == "sshfs":
            pass  # ssh is special...
        else:
            if self.is_mounted:
                res = self._unmount_udevil()
            else:
                res = self._mount_udevil()
        notify(res, self.is_mounted, self.label)

    def _mount_udevil(self):
        opts = self._add_credentials()
        return Popen(
            ["udevil", "mount", "-o", opts, "-t", self.mtype, self.path],
            stdout=PIPE,
            stderr=PIPE,
            text=True,
        )

    def _unmount_udevil(self):
        mountpoint = self._get_mountpoint()
        if mountpoint:
            return Popen(
                ["udevil", "unmount", mountpoint], stdout=PIPE, stderr=PIPE, text=True,
            )

    def _get_mountpoint(self):
        with open("/proc/mounts", "r") as f:
            for l in f:
                if self.path in l:
                    return l.split(" ")[1]

    def _add_credentials(self):
        if self.creds:
            if self.creds.startswith("secret:"):
                query = self.creds.replace("secret:", "")
                # TODO this might need to change depending on the
                # protocol
                passwd = self._get_secret(query)
                return "{},password={}".format(self.options, passwd)
        return self.options

    def _get_secret(self, query):
        cmd = ["secret-tool", "lookup"] + re.split("[=,]", query)
        return Popen(cmd, stdout=PIPE, stderr=STDOUT, text=True).communicate()[0]


def udiskie_init(line):
    is_mounted, is_fs, path, label = line[1:-1].split(" ")
    if is_fs == "True":
        is_mounted = is_mounted == "True"
        return UdiskieDevice(is_mounted, path, label)


def remove_none(xs):
    return list(filter(lambda x: x is not None, xs))


def format_actions(actions):
    return "\n".join(list(map(lambda x: x.entry, actions)))


udiskie_out = (
    Popen(UDISKIE_CMD, stdout=PIPE, stderr=STDOUT, text=True)
    .communicate()[0]
    .strip()
    .split("\n")
)

udiskie_actions = (
    remove_none([udiskie_init(line) for line in udiskie_out])
    if len("".join(udiskie_out)) > 0
    else []
)

with open(GENERAL_MNTS_PATH, "r") as f:
    # TODO this assumes the tsv file has headers as the first row
    # this may or may not be true
    # assume this will output a [] if the file is empty
    general_out = f.read().rstrip("\n").split("\n")[1:]

general_actions = remove_none(
    [GenericDevice(*line.split("\t")) for line in general_out]
)

actions = udiskie_actions + general_actions

rofi_opts = "\n\n".join(
    [format_actions(a) for a in [udiskie_actions, general_actions] if len(a) > 0]
)

rofi_cmd = [
    "rofi",
    "-m",
    "-4",
    "-dmenu",
    "-theme-str",
    "#element.selected.normal { background-color: #999933; }",
    "-p",
    "Devices",
]

rofi_out = (
    Popen(rofi_cmd, stdout=PIPE, stderr=STDOUT, text=True, stdin=PIPE)
    .communicate(input=rofi_opts)[0]
    .rstrip()
)

if rofi_out != "":
    for a in actions:
        if a == rofi_out:
            a.run()
            break
